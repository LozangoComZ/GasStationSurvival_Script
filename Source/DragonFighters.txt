// This file is auto generated by ScriptLinker at 15:59:25 17/12/2024
// Sauce: https://github.com/NearHuscarl/ScriptLinker

/*
* author: Lozango com z
* description: 
* mapmodes: 
*/
        public static Random rnd = new Random();
        public static Events.PlayerDeathCallback m_playerDeathEvent = null;
        public static Events.PlayerMeleeActionCallback m_playerMeleeActionEvent = null;
        public void OnStartup()
        {
            m_playerDeathEvent = Events.PlayerDeathCallback.Start(OnPlayerDeath);
            m_playerMeleeActionEvent = Events.PlayerMeleeActionCallback.Start(OnPlayerMeleeAction);
            WaveManager.ManualSetup(Game.SurvivalWave);
            EnemySpawn.RefreshSpawnPoints();
            WaveManager.TryNextSession();
        }
        public void OnPlayerDeath(IPlayer player, PlayerDeathArgs args)
        {
            if (!args.Killed) return;
            foreach (Enemy e in Wave.EnemiesList.Where(en => en.ply == player))
            {
                OnEnemyDeath(e,args);
                return;
            }
            WaveManager.GameOverCheck();
        }
        public void OnPlayerMeleeAction(IPlayer player, PlayerMeleeHitArg[] args)
        {
            if (!EnemyByIPlayer.ContainsKey(player)) return;
            Enemy enemy = EnemyByIPlayer[player];
            int score = enemy.score;
            int interval = (200 / score) * 200;
            var status = "COOLDOWN";
            foreach(PlayerMeleeHitArg arg in args)
            {
                if (arg.IsPlayer) if (((IPlayer)arg.HitObject).IsBlocking) {
                    interval *= 2;
                    status = "STUNNED";
                    Game.PlayEffect("Smack", player.GetWorldPosition() + new Vector2(0, 10));
                }
            }
            if (interval < 200) return;
            var name = player.Name;
            player.SetInputMode(PlayerInputMode.Disabled);
            player.SetBotName(status);
            Events.UpdateCallback.Start((float e) => {
                if (!player.IsDead){
                    player.SetInputMode(PlayerInputMode.Enabled);
                    player.SetBotName(name);
                }
            }, (uint)(interval), 1);
        }
        /*public static void MsgG(object s) { Game.WriteToConsole("DEBUG: " + s.ToString()); }
        public static void MsgG(object s, string origin) { Game.WriteToConsole(origin+": "+s.ToString()); }
        */
        public static void MsgG(object s) { Game.ShowChatMessage("DEBUG: " + s.ToString()); }
        public static void MsgG(object s, string origin) { Game.ShowChatMessage(origin + ": " + s.ToString()); }

        public static float GetDifference(float a, float b)
        {
            return Math.Abs(a - b);
        }
        public static object DrawRandomObject(Dictionary<object, object> dic)
        {
            int totalChances = 0;
            foreach (int chance in dic.Values)
            {
                totalChances += chance;
            }
            int rndDraw = rnd.Next(0, totalChances);
            int acumulador = 0;
            for(int i = 0;i < dic.Values.Count;i++)
            {
                acumulador += (int)dic.Values.ToArray()[i];
                if (rndDraw < acumulador){
                    return (object)dic.Keys.ToArray()[i];
                }
            }
            throw new Exception("Cannot draw random object");
        }
        public class BossConfig : EnemyConfig
        {
        }
        public class Enemy
        {
            public Enemy(EnemyConfig ec)
            {
                ply = ec.GetSpawn().CreatePlayer();
                EnemyByIPlayer.Add(ply, this);
            }
            public IPlayer ply;
            public int score;
            public EnemyConfig Settings;
        }
        public static void OnEnemyDeath(Enemy enemy, PlayerDeathArgs args)
        {
            if (enemy.Settings == null) return;
            enemy.Settings.OnDeath(enemy);
            Game.TotalScore += enemy.score;
            MsgG("New score: " + Game.TotalScore.ToString(), "ONENEMYDEATH");
            WaveManager.TryNextSession();
            WaveManager.GameOverCheck();
        }
        public static Dictionary<IPlayer, Enemy> EnemyByIPlayer = new Dictionary<IPlayer, Enemy>() { };
        public static BotBehaviorSet GenericIA(int score)
        {
            BotBehaviorSet bbs = new BotBehaviorSet();
            bbs.OffensiveClimbingLevel = Math.Min(score / 200, 1f);
            bbs.OffensiveEnrageLevel = Math.Min(score / 200, 1f);
            bbs.OffensiveSprintLevel = Math.Min(score / 200, 0.8f);
            bbs.DefensiveRollFireLevel = Math.Min(score / 200, 1f);
            bbs.SearchForItems = false;
            bbs.SearchItems = SearchItems.None;
            return bbs;
        }
        public static Func<int, BotBehaviorSet> RookieIA = (int score) =>
        {
            BotBehaviorSet bbs = GenericIA(score);
            bbs.RangedWeaponAccuracy = score / 400;
            bbs.RangedWeaponAimShootDelayMax = (300 / score) * 1500;
            bbs.RangedWeaponAimShootDelayMin = bbs.RangedWeaponAimShootDelayMax - 500;
            bbs.RangedWeaponBurstPauseMax = bbs.RangedWeaponAimShootDelayMax / 3;
            bbs.RangedWeaponBurstPauseMin = bbs.RangedWeaponAimShootDelayMin / 3;
            bbs.DefensiveAvoidProjectilesLevel = Math.Min(score / 200, 1f);
            bbs.OffensiveSprintLevel = Math.Min(score / 150, 0.8f);
            bbs.SetMeleeActionsToEasy();
            if (score > 60)
            {
                bbs.SetMeleeActionsToNormal();
            }
            if (score > 90)
            {
                bbs.SetMeleeActionsToHard();
            }
            if (score > 130)
            {
                bbs.SetMeleeActionsToExpert();
            }
            return bbs;
        };
        public static Func<int, BotBehaviorSet> PunkIA = (int score) =>
        {
            BotBehaviorSet bbs = GenericIA(score);
            bbs.RangedWeaponAccuracy = score / 150;
            bbs.RangedWeaponAimShootDelayMax = (200 / score) * 1500;
            bbs.RangedWeaponAimShootDelayMin = bbs.RangedWeaponAimShootDelayMax - 500;
            bbs.RangedWeaponBurstPauseMax = bbs.RangedWeaponAimShootDelayMax / 2;
            bbs.RangedWeaponBurstPauseMin = bbs.RangedWeaponAimShootDelayMin / 2;
            bbs.RangedWeaponPrecisionAccuracy = bbs.RangedWeaponAccuracy;
            bbs.RangedWeaponPrecisionAimShootDelayMax = bbs.RangedWeaponAimShootDelayMax;
            bbs.RangedWeaponPrecisionAimShootDelayMin = bbs.RangedWeaponAimShootDelayMin;
            bbs.RangedWeaponPrecisionBurstPauseMax = bbs.RangedWeaponBurstPauseMax;
            bbs.RangedWeaponPrecisionBurstPauseMin = bbs.RangedWeaponBurstPauseMin;
            bbs.SeekCoverWhileShooting = 1;
            bbs.OffensiveClimbingLevel = Math.Min(score / 200, 1f);
            bbs.OffensiveEnrageLevel = Math.Min(score / 200, 1f);
            bbs.OffensiveSprintLevel = Math.Min(score / 500, 0.8f);
            bbs.SetMeleeActionsToEasy();
            if (score > 80)
            {
                bbs.SetMeleeActionsToNormal();
            }
            if (score > 150)
            {
                bbs.SetMeleeActionsToHard();
            }
            if (score > 200)
            {
                bbs.SetMeleeActionsToExpert();
            }
            return bbs;
        };
        public static Func<int, BotBehaviorSet> MolotovIA = (int score) =>
        {
            BotBehaviorSet bbs = PunkIA(score);
            return bbs;
        };
        public static Func<int, BotBehaviorSet> BigIA = (int score) =>
        {
            BotBehaviorSet bbs = RookieIA(score);
            bbs.RangedWeaponUsage = false;
            bbs.OffensiveClimbingLevel = 1;
            bbs.OffensiveEnrageLevel = 1;
            bbs.OffensiveSprintLevel = 1;
            return bbs;
        };
        public static Func<int, BotBehaviorSet> SuicideIA = (int score) =>
        {
            BotBehaviorSet bbs = RookieIA(score/2);
            bbs.RangedWeaponAccuracy = 0.5f;
            bbs.DefensiveAvoidProjectilesLevel = 0;
            bbs.OffensiveSprintLevel = 0;
            bbs.OffensiveDiveLevel = 1;
            bbs.OffensiveClimbingLevel = 1;
            bbs.OffensiveEnrageLevel = 1;
            return bbs;
        };
        public partial class EnemyConfig
        {
            public string Name = "Debug";
            public int BaseScore = 0;
            public List<string> profilesID = new List<string>();
            public List<IProfile> GetProfiles()
            {
                if (profilesID.Count <= 0) return new List<IProfile> { new IProfile() };
                List<IObjectPlayerProfileInfo> altProfilesObj = new List<IObjectPlayerProfileInfo>();
                foreach (string profId in profilesID)
                {
                    foreach (IObject obj in Game.GetObjectsByCustomID("PP-" + profId.ToUpper()))
                    {
                        altProfilesObj.Add((IObjectPlayerProfileInfo)obj);
                    }
                }
                return altProfilesObj.Select(profObj => profObj.GetProfile()).ToList();
            }
            public IObjectPlayerSpawnTrigger GetSpawn() { return (IObjectPlayerSpawnTrigger)Game.GetObject("SPAWNER"); }
            public float healthMultiplier = 1;
            public float forceMultiplier = 1;
            public float energyMultiplier = 1;
            public float baseSize = -1;
            public float meleePreference = 1;
            public float handgunPreference = 1;
            public float riflePreference = 1;
            public Dictionary<WeaponItem, int> specialWpns = new Dictionary<WeaponItem, int>();
            public Action<Enemy> OnSpawn = (Enemy ec) => { };
            public Action<Enemy> OnDeath = (Enemy ec) => { };
            public Func<int, BotBehaviorSet> BotIASet;
        }
        public static readonly List<EnemyConfig> EnemyConfigList = new List<EnemyConfig>(){
            new EnemyConfig
            {
                Name = "ROOKIE",
                profilesID = { "DefaultMale", "DefaultFemale" },
                meleePreference = 1f,
                handgunPreference = 0.80f,
                riflePreference = 0.30f,
                BotIASet = RookieIA,
            },
            new EnemyConfig
            {
                Name = "PUNK",
                profilesID = { "DefaultMale", "DefaultFemale" },
                meleePreference = 0.25f,
                handgunPreference = 1.30f,
                riflePreference = 1.30f,
                BotIASet = PunkIA,
                forceMultiplier = 0.5f
            },
            new EnemyConfig
            {
                Name = "MOLOTOV",
                profilesID = { "MOLOTOV" },
                meleePreference = 0f,
                handgunPreference = 1.30f,
                riflePreference = 1.30f,
                specialWpns = new Dictionary<WeaponItem, int>()
                {
                    {WeaponItem.MOLOTOVS,0}
                },
                BotIASet = MolotovIA
            },
            new EnemyConfig
            {
                Name = "SUICIDE",
                profilesID = { "SUICIDE" },
                meleePreference = 0,
                handgunPreference = 0,
                riflePreference = 0,
                energyMultiplier = 1.50f,
                healthMultiplier = 0.25f,
                forceMultiplier = 0.5f,
                BotIASet = SuicideIA,
                OnDeath = (Enemy ec) =>
                {
                    new Timer(3, ec.ply, () =>
                    {
                        Game.TriggerExplosion( ec.ply.GetWorldPosition() );
                    });
                }
            },
            new EnemyConfig
            {
                Name = "BIG",
                profilesID = { "BIG" },
                meleePreference = 1.5f,
                handgunPreference = 0,
                riflePreference = 0,
                BotIASet = BigIA,
                baseSize = 1.10f,
                forceMultiplier = 1.25f,
                healthMultiplier = 1.5f
            }
        };
        public static EnemyConfig getEnemyConfigByName(string name)
        {
            foreach(EnemyConfig eC in EnemyConfigList)
            {
                if (eC.Name == name.ToUpper()) return eC;
            }
            throw new Exception("Tried to get a EnemyConfig that doesn't exist.");
        }
        public static EnemyConfig GetEnemyConfigByChance(float score)
        {
            EnemySpawnChance enemySpawnChance = WaveManager.CurrentSession().enemySpawnChance;
            List<EnemyConfig> enemyConfigs = enemySpawnChance.enemyConfigs;
            List<int> configsMinScore = enemySpawnChance.configsMinScore;
            List<int> configsChance = enemySpawnChance.configsChance;
            List<EnemyConfig> filteredEnemyConfigs = new List<EnemyConfig>();
            List<int> filteredConfigChances = new List<int>();
            for (int i = 0; i < enemyConfigs.Count; i++)
            {
                if (score > enemySpawnChance.configsMinScore[i])
                {
                    filteredEnemyConfigs.Add(enemyConfigs[i]);
                    filteredConfigChances.Add(configsChance[i]);
                }
            }
            if (filteredConfigChances.Count == 0 || filteredEnemyConfigs.Count == 0)
                throw new Exception("Cannot get a valid EnemyConfig sort list");
            var dic = filteredEnemyConfigs.Zip(filteredConfigChances, (key, value) => new { key, value }).ToDictionary(item => (object)item.key, item => (object)item.value);
            return (EnemyConfig)DrawRandomObject(dic);
        }
        public class EnemyScore
        {
            public static int[] ShareScore(int enemyCount, int initScore, double scoreConcentration, int minScorePerIndividual)
            {
                int minScore = 20;
                int reservedScore = minScore * enemyCount;
                if (initScore < reservedScore) { MsgG("Error: Session has insufficient score", "SHARESCORE"); return null; }
                int score = initScore - reservedScore;
                double[] weights = new double[enemyCount];
                for (int i = 0; i < enemyCount; i++)
                {
                    weights[i] = Math.Pow(i + 1, scoreConcentration);
                }
                double weightsSum = weights.Sum();
                int[] finalScoreList = new int[enemyCount];
                for (int i = 0; i < enemyCount; i++)
                {
                    finalScoreList[i] = (int)Math.Round((weights[i] / weightsSum) * score) + minScore;
                }
                return finalScoreList;
            }
            public static EnemyConfig GetEnemyTemplateByBaseScore(float baseScore)
            {
                return EnemyConfigList.OrderBy(x => GetDifference(x.BaseScore, baseScore)).First();
            }
        }
        public static class EnemySpawn
        {
            private static Vector2[] SpawnPoints;
            public static void RefreshSpawnPoints()
            {
                IObject[] objs = Game.GetObjects("ENEMYSPAWNPOINT");
                SpawnPoints = objs.Select(obj => obj.GetWorldPosition()).ToArray();
            }
            public static Enemy SpawnEnemy(int score)
            {
                Vector2 SpawnPoint = SpawnPoints[rnd.Next(0, SpawnPoints.Length)];
                EnemyConfig EnemySet = GetEnemyConfigByChance(score);
                MsgG(String.Concat("Spawning new enemy. Score: ", score.ToString(), " / Set: ", EnemySet.Name), "SPAWNENEMY");
                Enemy newEnemy = new Enemy(EnemySet);
                score -= EnemySet.BaseScore;
                newEnemy.Settings = EnemySet;
                newEnemy.score = score;
                IPlayer ply = newEnemy.ply;
                PlayerModifiers newMod = ply.GetModifiers();
                newMod.MaxHealth = (int)((score / 2) * EnemySet.healthMultiplier);
                newMod.CurrentHealth = newMod.MaxHealth;
                newMod.MeleeDamageDealtModifier = (score / 150f) * EnemySet.forceMultiplier;
                newMod.MeleeForceModifier = (score / 180f) * EnemySet.forceMultiplier;
                newMod.SizeModifier = EnemySet.baseSize;
                newMod.MaxEnergy = (int)(100 * EnemySet.energyMultiplier);
                ply.SetModifiers(newMod);
                int wpnScore = score;
                if (wpnScore < 0) wpnScore = 0;
                EnemyWeapon.WeaponSet wpnSet = EnemyWeapon.GetWeaponSet(wpnScore, EnemySet, rnd.Next(-10, 10));
                ply.GiveWeaponItem(wpnSet.meleeWpn);
                ply.GiveWeaponItem(wpnSet.handgunWpn);
                ply.GiveWeaponItem(wpnSet.rifleWpn);
                ply.GiveWeaponItem(wpnSet.specialWpn);
                IProfile profile = EnemySet.GetProfiles()[rnd.Next(EnemySet.GetProfiles().Count)];
                ply.SetProfile(profile);
                ply.SetBotBehaviorSet(EnemySet.BotIASet(score));
                ply.SetWorldPosition(SpawnPoint);
                ply.SetCameraSecondaryFocusMode(CameraFocusMode.Ignore);
                ply.SetBotName(score.ToString() + " " + EnemySet.Name);
                ply.SetInputMode(PlayerInputMode.Disabled);
                Events.UpdateCallback.Start((float e) => {
                    ply.SetInputMode(PlayerInputMode.Enabled);
                }, (uint)800, 1);
                return newEnemy;
            }
        }
        public static class EnemyWeapon{
            public static Dictionary<WeaponItem, int> MeleeWpnCostDic = new Dictionary<WeaponItem, int>
                {
                    {WeaponItem.NONE,30},
                    {WeaponItem.BOTTLE,50},
                    {WeaponItem.HAMMER,60},
                    {WeaponItem.PIPE,80},
                    {WeaponItem.LEAD_PIPE,100},
                    {WeaponItem.BAT,110},
                    {WeaponItem.CHAIN,150},
                };
            public static Dictionary<WeaponItem, int> HandgunWpnCostDic = new Dictionary<WeaponItem, int>
                {
                    {WeaponItem.NONE,50},
                    {WeaponItem.PISTOL,60},
                    {WeaponItem.REVOLVER,100},
                    {WeaponItem.UZI,200},
                    {WeaponItem.SUB_MACHINEGUN,200}
                };
            public static Dictionary<WeaponItem, int> RifleWpnCostDic = new Dictionary<WeaponItem, int>
                {
                    {WeaponItem.NONE,100},
                    {WeaponItem.SAWED_OFF,150},
                    {WeaponItem.SHOTGUN,200},
                    {WeaponItem.TOMMYGUN,250}
                };
            public class WeaponSet
            {
                public WeaponItem meleeWpn = WeaponItem.NONE;
                public WeaponItem handgunWpn = WeaponItem.NONE;
                public WeaponItem rifleWpn = WeaponItem.NONE;
                public WeaponItem specialWpn = WeaponItem.NONE;
            }
            public static WeaponSet GetWeaponSet(int score, EnemyConfig enemyConfig, int randomGap)
            {
                int currentScore = score;
                WeaponSet weaponSet = new WeaponSet();
                float meleePreference = enemyConfig.meleePreference;
                float handgunPreference = enemyConfig.handgunPreference;
                float riflePreference = enemyConfig.riflePreference;
                KeyValuePair<WeaponItem, int> melee;
                KeyValuePair<WeaponItem, int> handgun;
                KeyValuePair<WeaponItem, int> rifle;
                Action buyRifle = () => {
                    rifle = RifleWpnCostDic.OrderBy(x => GetDifference(x.Value, (currentScore * riflePreference) + randomGap)).First();
                    weaponSet.rifleWpn = rifle.Key;
                    if (weaponSet.rifleWpn != WeaponItem.NONE) currentScore -= rifle.Value;
                };
                Action buyHandgun = () => {
                    handgun = HandgunWpnCostDic.OrderBy(x => GetDifference(x.Value, (currentScore * handgunPreference) + randomGap)).First();
                    weaponSet.handgunWpn = handgun.Key;
                    if (weaponSet.handgunWpn != WeaponItem.NONE) currentScore -= handgun.Value;
                };
                Action buyMelee = () => {
                    melee = MeleeWpnCostDic.OrderBy(x => GetDifference(x.Value, (currentScore * meleePreference) + randomGap)).First();
                    weaponSet.meleeWpn = melee.Key;
                    if (weaponSet.meleeWpn != WeaponItem.NONE) currentScore -= melee.Value;
                };
                var wpnPerPreference = new Dictionary<Action, float>
                {
                    { buyRifle, enemyConfig.riflePreference},
                    { buyHandgun, enemyConfig.handgunPreference},
                    { buyMelee, enemyConfig.meleePreference}
                };
                var sortedBuy = wpnPerPreference
                    .OrderByDescending(par => par.Value)
                    .Select(par => par.Key)
                    .ToList();
                foreach (Action act in sortedBuy){
                    act();
                }
                if(enemyConfig.specialWpns.Keys.Count > 0) {
                    var special = enemyConfig.specialWpns.OrderBy(x => GetDifference(x.Value, (currentScore * riflePreference) + randomGap)).First();
                    weaponSet.specialWpn = special.Key;
                }
                return weaponSet;
            }
        }
        public class Timer
        {
            public Timer(int delayS, IObject followObj, Action onFinish)
            {
                delayRemain = delayS;
                text = (IObjectText)Game.CreateObject("Text");
                Action stop = () => { };
                Events.UpdateCallback m_followObjTick = null;
                Action<float> followObjTick = (float f) => {
                    if (followObj.IsRemoved)
                    {
                        stop();
                        return;
                    }
                    text.SetWorldPosition(followObj.GetWorldPosition());
                };
                Events.UpdateCallback m_timerTick = null;
                Action<float> timerTick = (float f) => {
                    if(delayRemain == 0) {
                        stop();
                        onFinish();
                        return;
                    }
                    delayRemain -= 1;
                    text.SetText(delayRemain.ToString());
                };
                /*
                Events.UpdateCallback m_colorTick = null;
                bool y = false;
                Action<float> colorTick = (float f) => {
                    if (y == false)
                    {
                        y = true;
                        text.SetTextColor(Color.Yellow);
                    }
                    else
                    {
                        y = false;
                        text.SetTextColor(Color.Red);
                    }
                };
                */
                stop = () =>
                {
                    m_followObjTick.Stop();
                    m_timerTick.Stop();
                    text.Remove();
                };
                m_timerTick = Events.UpdateCallback.Start(timerTick, 1000);
                m_followObjTick = Events.UpdateCallback.Start(followObjTick, 200);
            }
            public int delayRemain = -1;
            private IObjectText text;
        }
        public static class Wave
        {
            public static WaveConfig Settings;
            public static int CurrentSessionIndex = -1;
            public static List<Enemy> EnemiesList = new List<Enemy>();           //Todos inimigos em cena & inimigos em cena vivos
            public static List<Enemy> AliveEnemiesList { get { return EnemiesList.Where(enemy => !enemy.ply.IsDead).ToList(); } }
        }
        public static partial class WaveManager
        {
            public static void ManualSetup(int WAVEINDEX)
            {
                MsgG("Setting wave", "WAVEMANAGER");
                if (Wave.Settings != null) { MsgG("Already started.", "WAVEMANAGER"); return; }
                Wave.Settings = WaveConfigList[WAVEINDEX-1];
            }
            public static bool GameOverCheck()
            {
                if ((AllEnemiesIsDead() && IsFinalSession()) || AllPlayersIsDead())
                {
                    MsgG("Ending wave", "WAVEMANAGER");
                    Game.SetGameOver();
                    return true;
                }
                return false;
            }
            public static bool TryNextSession()
            {
                if (!AllEnemiesIsDead()) return false;
                Wave.CurrentSessionIndex += 1;
                if (IsFinalSession()){
                    MsgG("All spawn session are already spawned", "WAVEMANAGER");
                    return false;
                }
                SpawnSessionEnemies();
                return true;
            }
            private static void SpawnSessionEnemies()
            {
                MsgG("Spawning enemy session", "WAVEMANAGER");
                int[] ScorePerEnemy = EnemyScore.ShareScore(CurrentSession().EnemyUnits,CurrentSession().ScorePerEnemy * CurrentSession().EnemyUnits,CurrentSession().ScoreConcentration,100);
                for (int i = 0; i < CurrentSession().EnemyUnits; i++)
                {
                    int scr = ScorePerEnemy[i];
                    Events.UpdateCallback.Start((float e) => {
                        Wave.EnemiesList.Add(EnemySpawn.SpawnEnemy(scr));
                    }, (uint)(600 * (i+1)), 1);
                }
            }
            public static bool IsFinalSession(){        //Checa se é a ultima sessão
                if (Wave.CurrentSessionIndex == Wave.Settings.SessionsArray.Count) return true;
                return false;
            }
            public static bool AllEnemiesIsDead(){      //Checa se todos os inimigos estão mortos
                if (Wave.AliveEnemiesList.Count < 1) return true;
                return false;
            }
            public static bool AllPlayersIsDead(){      //Checa se todos os players (non-bots) estão mortos
                if (Game.GetPlayers().Where(x => x.GetTeam() == PlayerTeam.Team1 && !x.IsDead).ToArray().Length < 1) return true;
                return false;
            }
            public static WaveConfig.Session CurrentSession() { return Wave.Settings.SessionsArray[Wave.CurrentSessionIndex]; }
        }
        public class WaveConfig
        {
            public class Session
            {
                public int EnemyUnits = 0;              //Quantidade de inimigos
                public int ScorePerEnemy = 0;           //Dificuldade distribuida entre todos os inimigos
                public double ScoreConcentration = 0;   //Concentração dos pontos nos inimigos. (0 = Distribuido igualmente; 1 = Distribui minimamente)
                public EnemySpawnChance enemySpawnChance = SpawnChanceInitial;
            }
            public List<Session> SessionsArray =    //*Será usada de index 0 até o final durante a leitura numa Wave.
            new List<Session>{
            };
        }
        public class EnemySpawnChance
        {
            public List<EnemyConfig> enemyConfigs = new List<EnemyConfig>{};
            public List<int> configsChance = new List<int> { };
            public List<int> configsMinScore = new List<int> { };
            public EnemySpawnChance(EnemyConfig[] enemyConfigs, int[] configsChance, int[] configsMinScore)
            {
                this.enemyConfigs = enemyConfigs.ToList();
                this.configsChance = configsChance.ToList();
                this.configsMinScore = configsMinScore.ToList();
            }
        }
        public static EnemySpawnChance SpawnChanceInitial {
            get{ 
                return new EnemySpawnChance(
                    new EnemyConfig[] {     
                        getEnemyConfigByName("ROOKIE"),
                        getEnemyConfigByName("PUNK"),
                    }
                    , new int[] { 10 , 10}, new int[] { 0 , 55}); 
            } 
        }
        public static EnemySpawnChance SpawnChanceMiddle
        {
            get
            {
                return new EnemySpawnChance(
                    new EnemyConfig[] {
                        getEnemyConfigByName("ROOKIE"),
                        getEnemyConfigByName("PUNK"),
                        getEnemyConfigByName("MOLOTOV"),
                        getEnemyConfigByName("BIG"),
                        getEnemyConfigByName("SUICIDE"),
                    }
                    , new int[] { 10, 10, 6, 4, 1000}, new int[] { 0, 60, 80, 80, 20 });
            }
        }
        public static readonly WaveConfig[] WaveConfigList = {
            new WaveConfig(){ //0
                SessionsArray ={
                    new WaveConfig.Session(){
                    EnemyUnits=1,
                    ScorePerEnemy=250,
                    ScoreConcentration=1,
                    enemySpawnChance = SpawnChanceMiddle,
                    },
                },
            },//Default
        };


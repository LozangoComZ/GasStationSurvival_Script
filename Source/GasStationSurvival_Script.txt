// This file is auto generated by ScriptLinker at 09:15:24 31/10/2024
// Sauce: https://github.com/NearHuscarl/ScriptLinker

/*
* author: Lozango
* description: 
* mapmodes: 
*/
        public static Random rnd = new Random();
        Events.PlayerDeathCallback m_playerDeathEvent = null;
        public void OnStartup()
        {
            m_playerDeathEvent = Events.PlayerDeathCallback.Start(OnPlayerDeath);
            WaveManager.ManualSetup(Game.SurvivalWave);
            EnemySpawn.RefreshSpawnPoints();
            WaveManager.TryNextSession();
        }
        public void OnPlayerDeath(IPlayer player, PlayerDeathArgs args)
        {
            if (!args.Killed) return;
            foreach (Enemy e in Wave.EnemiesList.Where(en => en.ply == player))
            {
                OnEnemyDeath(e,args);
                return;
            }
            WaveManager.GameOverCheck();
        }
        public static void Msg(object s) { Game.ShowChatMessage("DEBUG: " + s.ToString()); }
        public static void Msg(object s, string origin) { Game.ShowChatMessage(origin+": "+s.ToString()); }

        public static float GetDifference(float a, float b)
        {
            return Math.Abs(a - b);
        }
        public class Enemy
        {
            public IPlayer ply;
            public int score;
            public EnemyConfig Settings;
        }
        public static void OnEnemyDeath(Enemy enemy, PlayerDeathArgs args)
        {
            if (enemy.Settings == null) return;
            Game.TotalScore += enemy.score;
            Msg("New score: " + Game.TotalScore.ToString(), "ONENEMYDEATH");
            WaveManager.TryNextSession();
            WaveManager.GameOverCheck();
        }
        public static readonly List<EnemyConfig> EnemyConfigList = new List<EnemyConfig>(){
            new EnemyConfig
            {
                altProfilesID = { "DefaultMale", "DefaultFemale" }
            }
        };
        public class EnemyConfig
        {
            public string Name = "Debug";
            public int BaseScore = 0;
            public List<string> altProfilesID = new List<string>();
            public List<IProfile> GetAltProfiles(){
                if (altProfilesID.Count <= 0) return new List<IProfile>{ new IProfile()};
                List<IObjectPlayerProfileInfo> altProfilesObj = new List<IObjectPlayerProfileInfo>();
                foreach (string profId in altProfilesID){
                    foreach (IObject obj in Game.GetObjectsByCustomID("PP-" + profId)){
                        altProfilesObj.Add((IObjectPlayerProfileInfo)obj);
                    }
                }
                return altProfilesObj.Select(profObj => profObj.GetProfile()).ToList();
            }
            public IObjectPlayerSpawnTrigger GetSpawn() { return (IObjectPlayerSpawnTrigger)Game.GetObject("PS-" + Name.ToUpper()); }
        }
        public class EnemyScore
        {
            public static int[] ShareScore(int enemyCount, int initScore, double scoreConcentration, int minScorePerIndividual)
            {
                int minScore = 20;
                int reservedScore = minScore * enemyCount;
                if (initScore < reservedScore) { Msg("Error: Session has insufficient score", "SHARESCORE"); return null; }
                int score = initScore - reservedScore;
                double[] weights = new double[enemyCount];
                for (int i = 0; i < enemyCount; i++)
                {
                    weights[i] = Math.Pow(i + 1, scoreConcentration);
                }
                double weightsSum = weights.Sum();
                int[] finalScoreList = new int[enemyCount];
                for (int i = 0; i < enemyCount; i++)
                {
                    finalScoreList[i] = (int)Math.Round((weights[i] / weightsSum) * score) + minScore;
                }
                return finalScoreList;
            }
            public static EnemyConfig GetEnemyTemplateByBaseScore(float baseScore)
            {
                return EnemyConfigList.OrderBy(x => GetDifference(x.BaseScore, baseScore)).First();
            }
        }
        public static class EnemySpawn
        {
            private static Vector2[] SpawnPoints;
            public static void RefreshSpawnPoints()
            {
                IObject[] objs = Game.GetObjects("ENEMYSPAWNPOINT");
                SpawnPoints = objs.Select(obj => obj.GetWorldPosition()).ToArray();
            }
            public static Enemy SpawnEnemy(int score)
            {
                Vector2 SpawnPoint = SpawnPoints[rnd.Next(0, SpawnPoints.Length)];
                EnemyConfig EnemySet = EnemyScore.GetEnemyTemplateByBaseScore(score);
                Msg(String.Concat("Spawning new enemy. Score: ", score.ToString(), " / Set: ", EnemySet.Name), "SPAWNENEMY");
                Enemy newEnemy = new Enemy();
                newEnemy.score = score;
                newEnemy.Settings = EnemySet;
                newEnemy.ply = newEnemy.Settings.GetSpawn().CreatePlayer();
                IPlayer ply = newEnemy.ply;
                PlayerModifiers newMod = ply.GetModifiers();
                newMod.MaxHealth = (int)(score / 2);
                newMod.CurrentHealth = newMod.MaxHealth;
                newMod.MeleeDamageDealtModifier = score / 150f;
                newMod.MeleeForceModifier = score / 100f;
                newMod.SizeModifier = Math.Min((score < 100 ? 100 : score) / 100, 1.25f);
                ply.SetModifiers(newMod);
                int wpnScore = score;
                if (wpnScore < 0) wpnScore = 0;
                EnemyWeapon.WeaponSet wpnSet = EnemyWeapon.GetWeaponSet(wpnScore, (float)(rnd.NextDouble() + 1), rnd.Next(-10, 10));
                ply.GiveWeaponItem(wpnSet.meleeWpn);
                ply.GiveWeaponItem(wpnSet.handgunWpn);
                ply.GiveWeaponItem(wpnSet.rifleWpn);
                IProfile profile = EnemySet.GetAltProfiles()[rnd.Next(EnemySet.GetAltProfiles().Count)];
                ply.SetProfile(profile);
                ply.SetWorldPosition(SpawnPoint);
                ply.SetCameraSecondaryFocusMode(CameraFocusMode.Ignore);
                ply.SetBotName(score.ToString());
                return newEnemy;
            }
        }
        public static class EnemyWeapon{
            public static Dictionary<WeaponItem, int> MeleeWpnCostDic = new Dictionary<WeaponItem, int>
                {
                    {WeaponItem.NONE,50},
                    {WeaponItem.HAMMER,70},
                    {WeaponItem.PIPE,80},
                    {WeaponItem.LEAD_PIPE,100},
                    {WeaponItem.BAT,110},
                    {WeaponItem.CHAIN,150},
                };
            public static Dictionary<WeaponItem, int> HandgunWpnCostDic = new Dictionary<WeaponItem, int>
                {
                    {WeaponItem.NONE,50},
                    {WeaponItem.PISTOL,60},
                    {WeaponItem.PISTOL45,100},
                    {WeaponItem.UZI,120},
                    {WeaponItem.MAGNUM,200}
                };
            public static Dictionary<WeaponItem, int> RifleWpnCostDic = new Dictionary<WeaponItem, int>
                {
                    {WeaponItem.NONE,100},
                    {WeaponItem.SHOTGUN,200},
                    {WeaponItem.TOMMYGUN,400},
                    {WeaponItem.ASSAULT,400}
                };
            public class WeaponSet
            {
                public WeaponItem meleeWpn = WeaponItem.NONE;
                public WeaponItem handgunWpn = WeaponItem.NONE;
                public WeaponItem rifleWpn = WeaponItem.NONE;
            }
            public static WeaponSet GetWeaponSet(int score, float meleePreference, int randomGap)
            {
                int currentScore = score;
                WeaponSet weaponSet = new WeaponSet();
                KeyValuePair<WeaponItem, int> rifle = RifleWpnCostDic.OrderBy(x => GetDifference(x.Value, (currentScore / meleePreference) + randomGap)).First();
                weaponSet.rifleWpn = rifle.Key;
                if(weaponSet.rifleWpn != WeaponItem.NONE) currentScore -= rifle.Value;
                KeyValuePair<WeaponItem, int> handgun = HandgunWpnCostDic.OrderBy(x => GetDifference(x.Value, (currentScore / meleePreference) + randomGap)).First();
                weaponSet.handgunWpn = handgun.Key;
                if (weaponSet.handgunWpn != WeaponItem.NONE) currentScore -= handgun.Value;
                KeyValuePair<WeaponItem, int> melee = MeleeWpnCostDic.OrderBy(x => GetDifference(x.Value, (currentScore * meleePreference) + randomGap)).First();
                weaponSet.meleeWpn = melee.Key;
                if (weaponSet.meleeWpn != WeaponItem.NONE) currentScore -= melee.Value;
                return weaponSet;
            }
        }
        public static class Wave
        {
            public static WaveConfig Settings;
            public static int CurrentSessionIndex = -1;
            public static List<Enemy> EnemiesList = new List<Enemy>();           //Todos inimigos em cena & inimigos em cena vivos
            public static List<Enemy> AliveEnemiesList { get { return EnemiesList.Where(enemy => !enemy.ply.IsDead).ToList(); } }
        }
        public static partial class WaveManager
        {
            public static void ManualSetup(int WAVEINDEX)
            {
                Msg("Setting wave", "WAVEMANAGER");
                if (Wave.Settings != null) { Msg("Already started.", "WAVEMANAGER"); return; }
                Wave.Settings = WaveConfigList[WAVEINDEX-1];
            }
            public static bool GameOverCheck()
            {
                if ((AllEnemiesIsDead() && IsFinalSession()) || AllPlayersIsDead())
                {
                    Msg("Ending wave", "WAVEMANAGER");
                    Game.SetGameOver();
                    return true;
                }
                return false;
            }
            public static bool TryNextSession()
            {
                if (!AllEnemiesIsDead()) return false;
                Wave.CurrentSessionIndex += 1;
                if (IsFinalSession()){
                    Msg("All spawn session are already spawned", "WAVEMANAGER");
                    return false;
                }
                SpawnSessionEnemies();
                return true;
            }
            private static void SpawnSessionEnemies()
            {
                Msg("Spawning enemy session", "WAVEMANAGER");
                int[] ScorePerEnemy = EnemyScore.ShareScore(CurrentSession().EnemyUnits,CurrentSession().ScorePerEnemy * CurrentSession().EnemyUnits,CurrentSession().ScoreConcentration,100);
                for (int i = 0; i < CurrentSession().EnemyUnits; i++)
                {
                    Wave.EnemiesList.Add(EnemySpawn.SpawnEnemy(ScorePerEnemy[i]));
                }
            }
            public static bool IsFinalSession(){        //Checa se é a ultima sessão
                if (Wave.CurrentSessionIndex == Wave.Settings.SessionsArray.Count) return true;
                return false;
            }
            public static bool AllEnemiesIsDead(){      //Checa se todos os inimigos estão mortos
                if (Wave.AliveEnemiesList.Count < 1) return true;
                return false;
            }
            public static bool AllPlayersIsDead(){      //Checa se todos os players (non-bots) estão mortos
                if (Game.GetPlayers().Where(x => x.GetTeam() == PlayerTeam.Team1 && !x.IsDead).ToArray().Length < 1) return true;
                return false;
            }
            public static WaveConfig.Session CurrentSession() { return Wave.Settings.SessionsArray[Wave.CurrentSessionIndex]; }
        }
        public class WaveConfig
        {
            public class Session
            {
                public int EnemyUnits = 0;              //Quantidade de inimigos
                public int ScorePerEnemy = 0;           //Dificuldade distribuida entre todos os inimigos
                public double ScoreConcentration = 0;   //Concentração dos pontos nos inimigos. (0 = Distribuido igualmente; 1 = Distribui minimamente)
            }
            public List<Session> SessionsArray =    //*Será usada de index 0 até o final durante a leitura numa Wave.
            new List<Session>{
            };
        }
        public static readonly WaveConfig[] WaveConfigList = {
            new WaveConfig(){ //0
                SessionsArray ={
                    new WaveConfig.Session(){
                    EnemyUnits=3,
                    ScorePerEnemy=50,
                    ScoreConcentration=0.2
                    },
                    new WaveConfig.Session(){
                    EnemyUnits=3,
                    ScorePerEnemy=60,
                    ScoreConcentration=0.5
                    },
                    new WaveConfig.Session(){
                    EnemyUnits=4,
                    ScorePerEnemy=60,
                    ScoreConcentration=1
                    },
                    new WaveConfig.Session(){
                    EnemyUnits=4,
                    ScorePerEnemy=70,
                    ScoreConcentration=1.5
                    },
                    new WaveConfig.Session(){
                    EnemyUnits=4,
                    ScorePerEnemy=100,
                    ScoreConcentration=2
                    },
                }
            },//Default
        };

